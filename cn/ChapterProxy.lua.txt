slot0 = class("ChapterProxy", import(".NetProxy"))
slot0.CHAPTER_UPDATED = "ChapterProxy:CHAPTER_UPDATED"
slot0.CHAPTER_ADDED = "ChapterProxy:CHAPTER_ADDED"
slot0.CHAPTER_REMOVED = "ChapterProxy:CHAPTER_REMOVED"
slot0.CHAPTER_TIMESUP = "ChapterProxy:CHAPTER_TIMESUP"
slot0.CHAPTER_CELL_UPDATED = "ChapterProxy:CHAPTER_CELL_UPDATED"
slot0.SHAM_CHAPTER_UPDATED = "ChapterProxy:SHAM_CHAPTER_UPDATED"
slot0.SHAM_SHOP_UPDATED = "ChapterProxy:SHAM_SHOP_UPDATED"
slot0.GUILD_CHAPTER_UPDATED = "ChapterProxy:GUILD_CHAPTER_UPDATED"
slot0.LAST_MAP_FOR_ACTIVITY = "last_map_for_activity"
slot0.LAST_MAP = "last_map"

slot0.register = function (slot0)
	slot0:on(13001, function (slot0)
		slot1 = {}
		slot2 = pairs
		slot3 = slot0.data or {}

		for slot5, slot6 in slot2(slot3) do
			if slot6:getPlayType() == ChapterConst.TypeMainSub then
				slot1[slot5] = slot6
			end
		end

		slot0.data = {}

		for slot5, slot6 in ipairs(slot0.chapter_list) do
			if not pg.chapter_template[slot6.id] then
				Debugger.LogError("chapter_template not exist: " .. slot6.id)
			elseif slot0.data[Chapter.New(slot6).id] then
				slot0:updateChapter(slot7)
			else
				slot0:addChapter(slot7)
			end
		end

		for slot5, slot6 in pairs(slot1) do
			if slot0.data[slot5] then
				slot7.expireTime = slot6.expireTime
				slot7.awardIndex = slot6.awardIndex
			else
				slot0.data[slot5] = slot6
			end
		end

		if slot0.current_chapter and slot0.current_chapter.id > 0 then
			slot0.data[slot2] or Chapter.New({
				id = slot2
			}):update(slot0.current_chapter)

			if slot0.data[slot2] then
				slot0:updateChapter(slot3)
			else
				slot0:addChapter(slot3)
			end
		end

		slot0.repairTimes = slot0.daily_repair_count
		Map.lastMap = slot0:getLastMap(slot1.LAST_MAP)
		Map.lastMapForActivity = slot0:getLastMap(slot1.LAST_MAP_FOR_ACTIVITY)
	end)
	slot0:on(13105, function (slot0)
		if slot0:getActiveChapter() then
			slot2 = 0

			if #slot0.map_update > 0 then
				_.each(slot0.map_update, function (slot0)
					if slot0.item_type ~= ChapterConst.AttachBorn_Sub then
						slot0:mergeChapterCell(ChapterCell.New(slot0))
					end
				end)

				slot2 = bit.bor(slot2, bit.bor(ChapterConst.DirtyAttachment, ChapterConst.DirtyAutoAction))
			end

			if #slot0.ai_list > 0 then
				_.each(slot0.ai_list, function (slot0)
					slot0:mergeChampion(ChapterChampion.New(slot0))
				end)

				slot2 = bit.bor(slot2, bit.bor(ChapterConst.DirtyChampion, ChapterConst.DirtyAutoAction))
			end

			slot0:updateChapter(slot1, slot2)
		end
	end)

	slot0.shamChapter = ShamChapter.New()
	slot0.shamShop = ShamBattleShop.New(0, {})

	slot0:on(23001, function (slot0)
		slot1 = slot0.sim_id

		if not ChapterConst.ActivateMirror then
			if not slot1 or not pg.sim_battle_template[slot1] then
				slot1 = os.server_date("*t", pg.TimeMgr.GetInstance():GetServerTime()).month
			end

			slot0.shamShop:update(slot1, slot0.shop_list or {})

			slot0.shamChapter.simId = slot1
		elseif not pg.sim_battle_template[slot1] then
			slot0.shamShop = nil
		else
			slot0.shamShop:update(slot1, slot0.shop_list or {})
		end

		slot0.shamChapter.shamResetCount = slot0.sham_count

		if slot0.shamChapter:isFirstDay() and slot0.shamChapter.shamResetCount == 0 then
			slot0.shamChapter.shamResetCount = 1
		end

		slot0.shamChapter.repairTimes = slot0.daily_repair_count

		if slot0.current_sham and slot0.current_sham.id > 0 and pg.sham_battle_template[slot0.current_sham.id] then
			slot0.shamChapter:update(slot0.current_sham)
		else
			slot0:localLoadShamChapter()
		end
	end)
	slot0:on(23009, function (slot0)
		slot1 = slot0:getShamChapter()

		if #slot0.cell_list > 0 then
			_.each(slot0.cell_list, function (slot0)
				slot0:mergeChapterCell(ChapterCell.New(slot0))
			end)
			slot0:updateShamChapter(slot1, bit.bor(ChapterConst.DirtyAttachment, ChapterConst.DirtyAutoAction))
		end
	end)

	slot0.guildChapter = GuildChapter.New()

	slot0:on(61001, function (slot0)
		if slot0 ~= nil then
			slot0.guildChapter = GuildChapter.New()
			slot0.guildChapter.shamResetCount = slot0.guild_count
			slot0.guildChapter.repairTimes = slot0.daily_repair_count

			if slot0.current_guild and slot0.current_guild.id > 0 and pg.sham_battle_template[slot0.current_guild.id] then
				slot0.guildChapter:update(slot0.current_guild)
			else
				slot0:localLoadGuildChapter()
			end
		end
	end)
	slot0:on(61009, function (slot0)
		slot1 = slot0:guildChapter()

		if #slot0.cell_list > 0 then
			_.each(slot0.cell_list, function (slot0)
				slot0:mergeChapterCell(ChapterCell.New(slot0))
			end)
			slot0:updateGuildChapter(slot1, bit.bor(ChapterConst.DirtyAttachment, ChapterConst.DirtyAutoAction))
		end
	end)

	slot0.timers = {}
	slot0.mapEliteFleetCache = {}
	slot0.escortMaps = {}
	slot0.subNextReqTime = 0
	slot0.subRefreshCount = 0
	slot0.subProgress = 1
end

slot0.checkMirrorCount = function (slot0)
	if slot0.shamChapter == nil then
		return
	end

	if ChapterConst.ActivateMirror and slot0.shamChapter:isFirstDay() and slot0.shamChapter.shamResetCount == 0 then
		slot0.shamChapter.shamResetCount = 1
	end
end

slot0.addChapterListener = function (slot0, slot1)
	if not slot1.dueTime or not slot0.timers then
		return
	end

	if slot0.timers[slot1.id] then
		slot0.timers[slot1.id]:Stop()

		slot0.timers[slot1.id] = nil
	end

	function slot3()
		slot0.data[slot1.id].dueTime = nil

		slot0.data[slot1.id].data[nil.id]:display("times'up")
		slot0.data[slot1.id].data[nil.id].display:sendNotification("times'up".CHAPTER_UPDATED, {
			dirty = 0,
			chapter = slot0.data[slot1.id]:clone()
		})
		slot0.data[slot1.id].data[nil.id].display.sendNotification:sendNotification("times'up".CHAPTER_UPDATED.CHAPTER_TIMESUP)
	end

	if slot1.dueTime - pg.TimeMgr.GetInstance():GetServerTime() > 0 then
		slot0.timers[slot1.id] = Timer.New(function ()
			slot0()
			slot1.timers[slot2.id]:Stop()

			slot1.timers[slot2.id] = nil
		end, slot2, 1)

		slot0.timers[slot1.id]:Start()
	else
		slot3()
	end
end

slot0.removeChapterListener = function (slot0, slot1)
	if slot0.timers[slot1] then
		slot0.timers[slot1]:Stop()

		slot0.timers[slot1] = nil
	end
end

slot0.remove = function (slot0)
	for slot4, slot5 in pairs(slot0.timers) do
		slot5:Stop()
	end

	slot0.timers = nil
end

slot0.existChapter = function (slot0, slot1)
	return slot0.data[slot1] ~= nil
end

slot0.getChapterById = function (slot0, slot1)
	if slot0.data[slot1] then
		return slot0.data[slot1]:clone()
	else
		slot2 = Chapter.New({
			id = slot1
		})
		slot3 = slot2:getConfig("map")

		if slot2:getConfig("type") == Chapter.CustomFleet and slot0.mapEliteFleetCache[slot3] then
			slot2:setEliteFleetList(slot0.mapEliteFleetCache[slot3])
		end

		return slot2
	end
end

slot0.addChapter = function (slot0, slot1)
	slot0.data[slot1.id] = slot1:clone()

	slot0:addChapterListener(slot1)
	slot0.facade:sendNotification(slot0.CHAPTER_ADDED, {
		dirty = -1,
		chapter = slot1:clone()
	})
end

slot0.updateChapter = function (slot0, slot1, slot2)
	slot3 = slot0.data[slot1.id]
	slot0.data[slot1.id] = slot1:clone()

	if not slot1:inWartime() then
		slot0:removeChapterListener(slot1.id)
	elseif not slot3 or slot3.dueTime ~= slot1.dueTime then
		slot0:addChapterListener(slot1)
	end

	slot0.facade:sendNotification(slot0.CHAPTER_UPDATED, {
		chapter = slot1:clone(),
		dirty = defaultValue(slot2, 0)
	})

	if slot0.data[slot1.id] and slot0.data[slot1.id].fleet then
		slot0.data[slot1.id].fleet:clearShipHpChange()
	end
end

slot0.removeChapter = function (slot0, slot1)
	if slot0.data[slot1] then
		slot0:removeChapterListener(slot1)

		slot0.data[slot1] = nil

		slot0.facade:sendNotification(slot0.CHAPTER_REMOVED, {
			dirty = -1,
			chapter = slot0.data[slot1]
		})
	end
end

slot0.duplicateEliteFleet = function (slot0, slot1, slot2)
	if slot1:getConfig("type") == Chapter.CustomFleet then
		slot1:EliteShipTypeFilter()

		slot0.mapEliteFleetCache[slot1:getConfig("map")] = slot1:getEliteFleetList()
		slot5 = {}

		for slot9, slot10 in pairs(slot0.data) do
			if slot10:getConfig("map") == slot4 and slot10.configId ~= slot1.configId then
				slot10:setEliteFleetList(slot3)

				if slot2 then
					slot0:updateChapter(slot10)
				end
			end
		end
	end
end

slot0.getMaps = function (slot0)
	slot1 = {}

	for slot6, slot7 in ipairs(pg.expedition_data_by_map.all) do
		slot1[slot7] = Map.New({
			id = slot7
		})
	end

	slot4 = getProxy(BayProxy).getRawData(slot3)

	for slot9, slot10 in ipairs(Chapter.bindConfigTable().all) do
		slot12 = slot1[slot5[slot10].map]

		if slot0.data[slot5[slot10].id] then
			for slot17, slot18 in ipairs(slot13:getEliteFleetList()) do
				slot19 = #slot18

				while slot19 > 0 do
					if slot4[slot18[slot19]] == nil then
						table.remove(slot18, slot19)
					end

					slot19 = slot19 - 1
				end
			end
		end

		slot14 = nil

		if slot13 then
			slot14 = slot13:clone()

			slot0:duplicateEliteFleet(slot13)
		elseif slot11.model ~= ChapterConst.TypeMainSub and Chapter.New({
			id = slot11.id
		}).getConfig(slot14, "type") == Chapter.CustomFleet and slot0.mapEliteFleetCache[slot12.configId] then
			slot14:setEliteFleetList(slot0.mapEliteFleetCache[slot12.configId])
		end

		if slot14 and slot14:isValid() then
			slot12:updateChapter(slot14)
		end
	end

	slot6 = true
	slot8 = getProxy(PlayerProxy).getData(slot7)
	slot9 = nil

	for slot13, slot14 in ipairs(slot2.all) do
		slot16 = slot1[slot14 + 1]

		slot1[slot14].updateChapters(slot15, slot9)

		slot17 = slot1[slot14].getConfig(slot15, "level_limit")

		if slot1[slot14].getMapType(slot15) == Map.SCENARIO then
			slot15:setUnlock(slot6 and slot17 <= slot8.level)

			if slot16 then
				slot6 = slot15:isClear() and slot16:getConfig("level_limit") <= slot8.level
			else
				slot6 = slot15:isClear()
			end
		elseif slot15:isActivity() then
			slot15:setUnlock(slot17 <= slot8.level and slot15:isAnyChapterUnlocked())
		else
			slot15:setUnlock(slot17 <= slot8.level)
		end

		slot9 = slot15

		if slot1[slot15:getBindMap()] then
			slot15:setBindMapVO(slot1[slot18])
		end
	end

	slot10 = {}
	slot12 = (slot0:getActiveChapter() and slot11.id) or 0

	for slot16, slot17 in pairs(slot1) do
		slot18 = _.any(_.values(slot17.chapters), function (slot0)
			return slot0.id == slot0
		end)

		if not slot17:isInValidMap() or slot18 then
			slot10[slot17.id] = slot17
		end
	end

	return slot10
end

slot0.getActiveChapter = function (slot0)
	for slot4, slot5 in pairs(slot0.data) do
		if slot5.active then
			return slot5:clone()
		end
	end
end

slot0.getNonActActiveChapter = function (slot0)
	for slot4, slot5 in pairs(slot0.data) do
		if not slot5:isActivity() and slot5.active then
			return slot5:clone()
		end
	end
end

slot0.getActActiveChapter = function (slot0)
	for slot4, slot5 in pairs(slot0.data) do
		if slot5:isActivity() and slot5.active then
			return slot5:clone()
		end
	end
end

slot0.getUnlockActMapBytype = function (slot0, slot1, slot2)
	slot3 = {}

	for slot8, slot9 in pairs(slot4) do
		if slot9:getConfig("type") == slot1 and slot9:getConfig("on_activity") == slot2 then
			table.insert(slot3, slot9)
		end
	end

	for slot8, slot9 in ipairs(slot3) do
		if slot9:getActiveChapter() then
			return slot9
		end
	end

	for slot8, slot9 in ipairs(slot3) do
		if slot4[slot9.id - 1] and slot10:isClearForActivity() and slot9:isUnlock() then
			return slot9
		end
	end

	table.sort(slot3, function (slot0, slot1)
		return slot0.id < slot1.id
	end)

	return slot3[1]
end

slot0.getLastMapForActivity = function (slot0)
	slot2, slot3 = nil

	if getProxy(ChapterProxy):getActActiveChapter() then
		slot2 = slot1.id
		slot3 = slot1:getConfig("map")
	else
		slot4 = slot0:getMaps()

		function slot5(slot0)
			return getProxy(ActivityProxy):getActivityById(slot0:getConfig("on_activity")) and not slot2:isEnd()
		end

		if Map.lastMapForActivity and slot4[Map.lastMapForActivity] and slot4[Map.lastMapForActivity]:isActivity() and slot5(slot4[Map.lastMapForActivity]) then
			slot3 = Map.lastMapForActivity
		else
			if Map.lastMapForActivity then
				Map.lastMapForActivity = nil

				slot0:recordLastMap(slot0.LAST_MAP_FOR_ACTIVITY, 0)
			end

			table.sort(slot6, function (slot0, slot1)
				return slot0.id < slot1.id
			end)

			if #getProxy(ActivityProxy):getActivitiesByType(ActivityConst.ACTIVITY_TYPE_ZPROJECT) > 0 then
				_.each(slot6, function (slot0)
					if _.all(_.select(_.values(slot0), function (slot0)
						return slot0:getConfig("on_activity") == slot0.id
					end), function (slot0)
						return slot0:isActivity() and slot0:getConfig("type") == Map.EVENT
					end) then
						_.each(slot1, function (slot0)
							if slot0:isUnlock() then
								slot0 = slot0.id
							end
						end)
					elseif _.any(slot1, function (slot0)
						return slot0:getConfig("type") == Map.ACTIVITY_EASY and not slot0:isClearForActivity()
					end) then
						_.each(slot1, function (slot0)
							if slot0:getConfig("type") == Map.ACTIVITY_EASY and slot0:isUnlock() then
								slot0 = slot0.id
							end
						end)
					else
						_.each(slot1, function (slot0)
							if slot0:getConfig("type") == Map.ACTIVITY_HARD and slot0:isUnlock() then
								slot0 = slot0.id
							end
						end)
					end
				end)
			end

			slot3 = slot3 or ActivityConst.ACTIVITY_BATTLE_MAP_ID
		end
	end

	return slot3, slot2
end

slot0.inWarTime = function (slot0)
	if slot0:getActiveChapter() then
		return slot1:inWartime()
	end
end

slot0.isInVaildFleet = function (slot0)
	return not slot0:getActiveChapter() or not slot1.fleet:isValid()
end

slot0.checkNextFleet = function (slot0)
	return not slot0:getActiveChapter() or slot1.fleet:isValid() or slot1:getNextValidIndex() <= 0
end

slot0.inChapterLine = function (slot0, slot1)
	if slot0:getActiveChapter() and slot2.fleet.line.row == slot1.row and slot2.fleet.line.column == slot1.column then
		if slot1.attachment and slot1.flag then
			return slot0:getChapterCell(slot1)
		end

		return true
	end
end

slot0.getChapterCell = function (slot0, slot1)
	if slot0:getActiveChapter() then
		return slot2:getChapterCell(slot1.row, slot1.column).attachment == slot1.attachment and slot3.flag == slot1.flag
	end
end

slot0.updateActiveChapterShips = function (slot0)
	for slot4, slot5 in pairs(slot0.data) do
		if slot5.active then
			_.each(slot5.fleets, function (slot0)
				slot0:flushShips()
			end)
		end
	end
end

slot0.resetRepairTimes = function (slot0)
	slot0.repairTimes = 0
end

slot0.getUseableMaxEliteMap = function (slot0)
	slot2 = {}

	for slot6, slot7 in pairs(slot1) do
		if slot7:getMapType() == Map.ELITE and slot7:isEliteEnabled() then
			slot2[#slot2 + 1] = slot7
		end
	end

	if #slot2 == 0 then
		return false
	end

	table.sort(slot2, function (slot0, slot1)
		return slot1.configId < slot0.configId
	end)

	return slot2[1]
end

slot0.eliteFleetRecommend = function (slot0, slot1, slot2)
	slot3 = getProxy(BayProxy)
	slot4 = slot1:getEliteFleetList()[slot2]
	slot6 = {}
	slot7 = {}
	slot8 = {
		0,
		0,
		0
	}

	if slot1:getConfig("limitation")[slot2] then
		slot6 = Clone(slot5[1])
		slot7 = Clone(slot5[2])
	end

	slot9 = getProxy(BayProxy):getRawData()
	slot10 = {}

	for slot14, slot15 in ipairs(slot1:getEliteFleetList()) do
		for slot19, slot20 in ipairs(slot15) do
			slot10[#slot10 + 1] = slot20
		end
	end

	slot11 = {
		[TeamType.Main] = slot6,
		[TeamType.Vanguard] = slot7,
		[TeamType.Submarine] = slot8
	}

	for slot15, slot16 in ipairs(slot4) do
		slot20 = 0
		slot21 = nil
		slot20 = (table.contains(slot11[pg.ship_data_by_type[slot9[slot16].getShipType(slot17)].team_type], slot9[slot16].getShipType(slot17)) and slot18) or 0

		for slot25, slot26 in ipairs(slot21) do
			if slot26 == slot20 then
				table.remove(slot21, slot25)

				break
			end
		end
	end

	function slot12(slot0)
		if slot0:getEliteRecommendShip(slot0, slot0.getEliteRecommendShip) then
			slot1[#slot1 + 1] = slot1.id
			slot1.id[#slot2 + 1] = slot1.id
		end
	end

	if slot2 >= 1 and slot2 <= 2 then
		for slot16, slot17 in ipairs(slot6) do
			slot18 = nil

			if type(slot17) == "string" then
				slot18 = Clone(ShipType.BundleList[slot17])
			elseif type(slot17) == "number" then
				slot12((slot17 ~= 0 or TeamType.MainShipType) and {
					slot17
				})
			end
		end

		for slot16, slot17 in ipairs(slot7) do
			slot18 = nil

			if type(slot17) == "string" then
				slot18 = Clone(ShipType.BundleList[slot17])
			elseif type(slot17) == "number" then
				slot12((slot17 ~= 0 or TeamType.VanguardShipType) and {
					slot17
				})
			end
		end
	else
		for slot16, slot17 in ipairs(slot8) do
			slot18 = nil

			if type(slot17) == "string" then
				slot18 = Clone(ShipType.BundleList[slot17])
			elseif type(slot17) == "number" then
				slot12((slot17 ~= 0 or TeamType.SubShipType) and {
					slot17
				})
			end
		end
	end
end

slot0.isClear = function (slot0, slot1)
	return slot0:getChapterById(slot1) and slot2:isClear()
end

slot0.getShamChapter = function (slot0)
	return Clone(slot0.shamChapter)
end

slot0.updateShamChapter = function (slot0, slot1, slot2)
	slot0.shamChapter = slot1

	slot0.facade:sendNotification(slot0.SHAM_CHAPTER_UPDATED, {
		shamChapter = slot1:clone(),
		dirty = defaultValue(slot2, 0)
	})
	slot0.shamChapter.fleet:clearShipHpChange()
end

slot0.updateShamChapterShips = function (slot0)
	slot0.shamChapter:flushShips()
end

slot0.localSaveShamChapter = function (slot0)
	slot0.shamChapter:localSaveChapter()
end

slot0.resetShamChapter = function (slot0)
	slot0.shamChapter.shamResetCount = 0
	slot0.shamChapter.repairTimes = 0
end

slot0.getShamShop = function (slot0)
	return Clone(slot0.shamShop)
end

slot0.updateShamShop = function (slot0, slot1)
	slot0.shamShop = slot1

	slot0:sendNotification(slot0.SHAM_SHOP_UPDATED)
end

slot0.localLoadShamChapter = function (slot0)
	slot0.shamChapter:localLoadChapter()
end

slot0.getGuildChapter = function (slot0)
	return Clone(slot0.guildChapter)
end

slot0.localLoadGuildChapter = function (slot0)
	slot0.guildChapter:localLoadChapter()
end

slot0.localSaveGuildChapter = function (slot0)
	slot0.guildChapter:localSaveChapter()
end

slot0.updateGuildChapter = function (slot0, slot1, slot2)
	slot0.guildChapter = slot1

	slot0.facade:sendNotification(slot0.GUILD_CHAPTER_UPDATED, {
		guildChapter = slot1:clone(),
		dirty = defaultValue(slot2, 0)
	})
	slot0.guildChapter.fleet:clearShipHpChange()
end

slot0.updateGuildChapterShips = function (slot0)
	if slot0.guildChapter then
		slot0.guildChapter:flushShips()
	end
end

slot0.getEscortShop = function (slot0)
	return Clone(slot0.escortShop)
end

slot0.updateEscortShop = function (slot0, slot1)
	slot0.escortShop = slot1
end

slot0.removeEscortChapter = function (slot0, slot1)
	for slot5, slot6 in ipairs(slot0.escortMaps) do
		for slot10 = #slot6.chapters, 1, -1 do
			if slot6.chapters[slot10].chapter.id == slot1 then
				table.remove(slot6.chapters, slot10)
			end
		end
	end
end

slot0.recordLastMap = function (slot0, slot1, slot2)
	slot3 = false

	if slot1 == slot0.LAST_MAP_FOR_ACTIVITY then
		Map.lastMapForActivity = slot2
		slot3 = true
	elseif slot1 == slot0.LAST_MAP and slot2 ~= Map.lastMap then
		Map.lastMap = slot2
		slot3 = true
	end

	if slot3 then
		PlayerPrefs.SetInt(slot1 .. getProxy(PlayerProxy):getRawData().id, slot2)
		PlayerPrefs.Save()
	end
end

slot0.getLastMap = function (slot0, slot1)
	if PlayerPrefs.GetInt(slot1 .. getProxy(PlayerProxy):getRawData().id) ~= 0 then
		return slot3
	end
end

return slot0
